using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#region oop
// 객체지향프로그래밍(OOP)

// 기존의 방식 : 프로그램은 명령어들의 집합
// 객체 지향식 설계 : 프로그램은 객체들의 모임
// 클래스 : 객체 지향 프로그래밍의 그본 구성요소이자 사용자 정의 데의터 타입
// >> 변수와 함수를 같이 저장할 수 있는 자료구조
// 객체 : 클래스가 실제로 메모리상에 할당된 인스턴스
// 필드 : 클래스 내부에 설계된 변수, 객체의 속성을 표현
// 메소드 : 클래스 내부에 설계된 함수, 객체의 기능, 동작을 표현

// 객체치향설계의 목적
// 1. 캡슐화 : 클래스 내부의 서로 연관되어있는 속성과 기능을 하나의 캡슐처럼 만들어
// 데이터가 외부로부터 노출되는 것을 방지하는 설계법

// 2. 상속 class 자식클래스명 : 부모클래스명
// 부모 클래스가 가진 변수와 함수를 상속받고 그 기능을 사용 가능
// 상황에 맞게 재정의하여 새로운 기능으로 만들어주는 것도 가능

// 3. 다형성 : 같은 이름의 변수, 함수여도 상황에 따라 다른 의미로 사용 가능 (조건에따라 다르게 수행)
#endregion

// 자료 구조(Data Structure)
// 효율적인 접근과 수정을 가능하게하는 자료의 조직, 관리, 저장, 데이터 값의 모임, 데이터의 관계 등

// 자주 사용하는 자료 구조

//LinkedList<T>                         데이터의 등록과 삭제가 빈번하게 발생하는 경우 사용
//List<T>                               데이터가 저장된 순서(인덱스)를 빠르게 탐색 가능
//Stack<T>                              데이터를 후입 선출 (LIFO)의 방식으로 사용
//Queue<T>                              데이터를 선입 선출(FIFO)의 방식으로 사용
//Dictionary<K, V>                      특정 Key를 통해 특정 값을 조회하는 경우에 사용
//HashSet<T>                            중복되지 않은 데이터를 저장하고자 할 때 사용 (수학적 집합)
// T[]                                  리스트처럼 데이터가 인덱스에 의해 관리, 메모리 상에 연속적으로 저장되는 자료구조
//                                      고정된 크기를 가지고 있고, 추가 소모되는 메모리 없이 딱 크기에 맞게 제공
//                                      유니티 에디터 상에선 배열과 리스트는 동일하게 취급되나 스크립트 작업시 배열과 리스트의 사용법이 다르니 유의

// 자료구조 별 알고리즘 단계의 수
// 데이터 원소 N개에 대한 알고리즘의 단계 수를 파악하면 해당자료구조가 빠른지 판단 가능
// O(1)     : 데이터의 증가, 감소에 영향을 받지 않고 단계 수가 일정하게 유지
// O(n)     : 데이터 추가 당 알고리즘이 1단계 씩 증가 데이터가 많아질 수록 작업의 효율이 나빠짐
// 0(log n) : 조금씩 증가하는 형태의 곡선으로 데이터가 약 2배 증가 할 때 마다 1단계정도 늘어남

// O(1) > O(log n) > O(n) 
// O(1)은 O(log n)과 비교했을 때 비등하다 데이터의 개수가 약 100개 이상을 넘을 경우 O(1)이 효율적

// 시간 복잡도 
// 명칭                     추가           검색          삭제          인덱스로 인한 접근
//LinkedList<T>             O(1)           O(n)          O(n)          O(n)
//List<T>                   O(1)           O(n)          O(n)          0(1)
//Stack<T>                  O(1)            -            O(1)           -
//Queue<T>                  O(1)            -            O(1)           -
//Dictionary<K, V>          O(1)           0(1)          0(1)           -(인덱스 대신에 키를 인덱스처럼 사용)
//HashSet<T>                O(1)           0(1)          0(1)           -
// T[]                      O(n)           O(n)          O(n)          O(1)
// 배열의 경우는 추가, 검색, 삭제의 기능이 없기 때문에 따로 로직을 짜서 실행 해야 함
// 배열은 다 만들어진 고정형 데이터에 대한 불필요한 메모리 낭비를 막기 위해 사용하는 경우가 가장 좋음.


public class OOPExample : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
